defmodule BamlElixir.Client do
  @moduledoc """
  A client for interacting with BAML functions.

  This module provides functionality to call BAML functions either synchronously or as a stream.

  ## Examples

      # Call a function synchronously
      {:ok, result} = BamlElixir.Client.call("MyFunction", %{arg1: "value"})

      # Stream function results
      stream = BamlElixir.Client.stream!("MyFunction", %{arg1: "value"})
      Enum.each(stream, fn result -> IO.inspect(result) end)
  """

  defstruct [
    :client_registry,
    from: "baml_src",
    collectors: []
  ]

  defmacro __using__(opts) do
    path = Keyword.get(opts, :path, "baml_src")

    quote do
      import BamlElixir.Client

      # Get BAML types
      baml_types = BamlElixir.Native.parse_baml(unquote(path))
      baml_class_types = baml_types[:classes]
      baml_enum_types = baml_types[:enums]

      # Generate types
      BamlElixir.Client.generate_class_types(__MODULE__, baml_class_types)
      BamlElixir.Client.generate_enum_types(__MODULE__, baml_enum_types)
    end
  end

  @doc false
  def generate_class_types(module, class_types) do
    for {type_name, fields} <- class_types do
      field_names = get_field_names(fields)
      field_types = get_field_types(fields)
      module_name = Module.concat([module, type_name])

      Module.create(
        module_name,
        quote do
          defstruct unquote(field_names)
          @type t :: %__MODULE__{unquote_splicing(field_types)}
        end,
        Macro.Env.location(__ENV__)
      )

      IO.puts("Generated BAML class module: #{inspect(module_name)}")
    end
  end

  @doc false
  def generate_enum_types(module, enum_types) do
    for {enum_name, variants} <- enum_types do
      variant_atoms = Enum.map(variants, &String.to_atom/1)
      module_name = Module.concat([module, enum_name])

      union_type =
        Enum.reduce(variant_atoms, fn atom, acc ->
          {:|, [], [atom, acc]}
        end)

      Module.create(
        module_name,
        quote do
          @type t :: unquote(union_type)
        end,
        Macro.Env.location(__ENV__)
      )

      IO.puts("Generated BAML enum module: #{inspect(module_name)}")
    end
  end

  defp get_field_names(fields) do
    for {field_name, _} <- fields do
      String.to_atom(field_name)
    end
  end

  defp get_field_types(fields) do
    for {field_name, field_type} <- fields do
      elixir_type =
        case field_type do
          "string" -> :string
          "int" -> :integer
          "float" -> :float
          "bool" -> :boolean
          # For custom types like Company
          _ -> :any
        end

      {String.to_atom(field_name), elixir_type}
    end
  end

  def new do
    %__MODULE__{}
  end

  def from(client = %__MODULE__{}, path) do
    %{client | from: path}
  end

  def add_collector(
        client = %__MODULE__{},
        %BamlElixir.Collector{reference: reference}
      )
      when is_reference(reference) do
    %{client | collectors: [reference | client.collectors]}
  end

  def use_llm_client(client = %__MODULE__{}, name) do
    %{client | client_registry: %{primary: name}}
  end

  @doc """
  Calls a BAML function synchronously.

  ## Parameters
    - `function_name`: The name of the BAML function to call
    - `args`: A map of arguments to pass to the function
    - `opts`: A map of options
      - `path`: The path to the BAML source file
      - `collectors`: A list of collectors to use
      - `llm_client`: The name of the LLM client to use

  ## Returns
    - `{:ok, term()}` on success, where the term is the function's return value
    - `{:error, String.t()}` on failure, with an error message

  ## Examples
      {:ok, result} = BamlElixir.Client.call(client, "MyFunction", %{arg1: "value"})
  """
  @spec call(String.t(), map(), map()) ::
          {:ok, term()} | {:error, String.t()}
  def call(function_name, args, opts \\ %{}) do
    {path, collectors, client_registry} = prepare_opts(opts)

    BamlElixir.Native.call(function_name, args, path, collectors, client_registry)
  end

  @doc """
  Calls a BAML function and returns a stream of results as tokens are generated by an LLM.

  ## Parameters
    - `function_name`: The name of the BAML function to call
    - `args`: A map of arguments to pass to the function
    - `opts`: A map of options
      - `path`: The path to the BAML source file
      - `collectors`: A list of collectors to use
      - `llm_client`: The name of the LLM client to use

  ## Returns
    - A stream of results

  ## Examples
      stream = BamlElixir.Client.stream!("MyFunction", %{arg1: "value"})
      Enum.each(stream, fn result -> IO.inspect(result) end)
  """
  @spec stream!(String.t(), map(), map()) :: Enumerable.t()
  def stream!(function_name, args, opts \\ %{}) do
    {path, collectors, client_registry} = prepare_opts(opts)

    Stream.resource(
      fn ->
        pid = self()

        spawn_link(fn ->
          send(
            pid,
            BamlElixir.Native.stream(
              pid,
              function_name,
              args,
              path,
              collectors,
              client_registry
            )
          )
        end)
      end,
      fn _ ->
        receive do
          {:ok, result} -> {[result], nil}
          :done -> {:halt, :done}
          {:error, reason} -> raise reason
        end
      end,
      fn _ -> :ok end
    )
  end

  defp prepare_opts(opts) do
    path = opts[:path] || "baml_src"
    collectors = (opts[:collectors] || []) |> Enum.map(fn collector -> collector.reference end)
    client_registry = opts[:llm_client] && %{primary: opts[:llm_client]}
    {path, collectors, client_registry}
  end
end
